It seems that the symbol is valid, but how to use it?

Symbol:
    __debugFlags:"ExportDoesNotSupportDefaultModifier|BlockScopedVariable"
    declarations:Array(1) [Node]
    escapedName:"square"
    exports:Map(0) {}
    flags:2
    id:undefined
    mergeId:undefined
    parent:undefined
    valueDeclaration:Node {pos: 5, end: 29, kind: 244, "square = Math.pow(?, 2)"}
    __proto__:Object {constructor: , __debugFlags: <accessor>}

checkVariableLikeDeclaration results in problem:
    the type of square MUST BE (x: number) => number

    Whole expression: 'const square = Math.pow(?, 2);'

    LHS = const square
        WORKS!
        const type = convertAutoToAny(getTypeOfSymbol(symbol));


    RHS = Math.pow(?, 2);
        Claims: number. Should be: (x: number) => number
        const initializer = getEffectiveInitializer(node);
        checkExpressionCached(initializer) |> 
            checkTypeAssignableToAndOptionallyElaborate)

    type returned from getTypeOfSymbol(symbol) MUST NOT BE ANY OF
        A) number
        B) () => (x: number) => number
        C) (2) => (x: number) => number

    We run checkExpressionCached(initializer):
        We go to CheckCallExpression -> getResolvedSignature -> resolveSignature -> resolveCallExpression which actually goes and checks Math.pow -function call.
            checkExpression -> checkExpressionWorker -> checkPropertyAccessExpression
                checkNonNullExpression: Retrieves Math.
                    First checks math with checkIdentifier and finds it valid.
                checkPropertyAccessExpressionOrQualifiedName: Retrives .pow from Math
                    Gets pow from Math
            Returns pow to resolveSignature -> CheckCallExpression
            resolveCall: Resolve the call to pow.
                getEffectiveCallArguments
                    Resolved [PartialApplicationElement, NumericLiteral]
                    chooseOverload
                        hasCorrectArity(?, y) - passes for that one.
                        getSignatureApplicabilityError
                            arg 0 (?):
                                getTypeAtPosition(signature, i);
                                checkExpressionWithContextualType(?, number)
                                    checkExpression(?)
            !!!!                            checkExpressionWorker - returns errorType for PartialApplicationElement
                            arg 0 (?):
                                getTypeAtPosition(signature, i);
                                checkExpressionWithContextualType(?, number)
                                    checkExpression(?)
            !!!!                            checkExpressionWorker - returns errorType for PartialApplicationElement
                            Returns undefined. So no error for some reason...
                ResolveCall returns the pow -call.
        checkExpressionCached returns (number) as pow's return value.

    Problem currently. The node and it's symbol return type doesn't match the initializer return type.
    checkTypeAssignableToAndOptionallyElaborate(number, (number, number) => number)

    In this function,
        The 'type' variable is the LHS of the assignment.
        The 'initializer' is the RHS of the assignment.


    Mutation happening!:
        checkTypeAssignableToAndOptionallyElaborate -> checkTypeRelatedToAndOptionallyElaborate -> isTypeRelatedTo